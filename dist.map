{"version":3,"sources":["src/angular-enforcer.js"],"names":[],"mappings":"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","file":"dist","sourcesContent":["#!/usr/bin/env node\n\nimport path from 'path';\nimport _ from 'lodash';\nimport { DefaultHandler, Parser, DomUtils } from 'htmlparser2';\nimport wrap from 'wordwrap';\nimport minimist from 'minimist';\nimport 'string.prototype.repeat';\n\nconst options = {\n    tab_length: 4,\n    line_max: 100,\n    selfClosingTags: false\n}\n\nconst selfClosingTags = [\n    'area',\n    'base',\n    'br',\n    'col',\n    'command',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'keygen',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr'\n];\n\n// tags to ignore wrapping\nconst ignoredWrapTags = [\n    'script', 'style'\n];\n\n// format an attribute value\nfunction formatValue(value, indent) {\n    if (value[0] === '{' && _.last(value) === '}') {\n        let spaces = ' '.repeat(indent);\n        return value.replace(/\\,\\s\\'/g, ',\\n'+ spaces +'\\'');\n    }\n    return value;\n}\n\nfunction isSelfClosing(node){\n    return _.includes(selfClosingTags, node.name);\n}\n\n// function to get just the start tag inner text (no <>)\nfunction getRaw(node){\n    let text = '';\n    text += node.name;\n    _.each(node.attribs, (value, key) => {\n        text += ' ' +key + '=\"' + value + '\"';\n    });\n    return text;\n}\n\nfunction canEndSameLine(node, text, spaces, raw) {\n    if (!node.name ||\n        isSelfClosing(node) ||\n        node.type === 'text' ||\n        (spaces.length + raw.length) > options.line_max) {\n        return false;\n    }\n    const additional_chars = _.last(text.split('\\n')).length + node.name.length + 3;\n    return node.children.length === 0 && additional_chars <= options.line_max;\n}\n\nfunction formateNodeHeader(node, spaces, level) {\n    let text = '';\n    let rawNode = getRaw(node);\n    if (node.name) {\n        if ((spaces.length + rawNode.length + 3) <= options.line_max) {\n            if (isSelfClosing(node) && options.selfClosingTags) {\n                text = spaces + '<' + rawNode + ' />\\n';\n            } else {\n                text = spaces + '<' + rawNode + '>\\n';\n            }\n        } else {\n            let attrs = _.pairs(node.attribs);\n            text = spaces + '<' + node.name + ' ';\n            // format attributes\n            attrs.forEach(([attrName, attrValue], index) => {\n                if (index > 0) {\n                    text += spaces + ' '.repeat(options.tab_length);\n                }\n                text += attrName + '=\"';\n                const indent = _.last(text.split('\\n')).length + 1;\n                text += formatValue(attrValue, indent) +'\"';\n                if (index === attrs.length-1) {\n                    text += '>\\n';\n                } else {\n                    text += '\\n';\n                }\n            });\n        }\n    }\n    if (canEndSameLine(node, text, spaces, rawNode)) {\n        text = text.substring(0, text.length - 1);\n    }\n    return text;\n}\n\nfunction breakLongLines(line) {\n    if (line.length > options.line_max) {\n        let words = line.split(' ');\n        let spaceLeft = options.line_max;\n        words.forEach((word) => {\n            if (word.length > spaceLeft) {\n                word = '\\n' + word\n                spaceLeft = options.line_max - word.length;\n            } else {\n                spaceLeft -= word.length;\n            }\n        });\n        return words.join(' ');\n    }\n    return line;\n}\n\nfunction parseNode(node, level=0) {\n    //console.log('\\n\\n', node);\n    let text = '';\n    let spaces = spaces = ' '.repeat(options.tab_length).repeat(level);\n    text += formateNodeHeader(node, spaces, level);\n    let sameLineEnding = text[text.length - 1] !== '\\n';\n    if (node.children) {\n        node.children.forEach((child) => {\n            text += parseNode(child, level + 1);\n        });\n    }\n    if (node.type === 'text' && node.parent && !_.includes(ignoredWrapTags, node.parent.type)) {\n        let wrapLine = wrap(spaces.length, options.line_max);\n        let wrappedText = wrapLine(node.data);\n        console.log(wrappedText);\n        text += spaces + decodeURI().trim() + '\\n';\n    }\n    if (node.name && !isSelfClosing(node)) {\n        if (sameLineEnding){\n            text += '</' + node.name + '>\\n';\n        } else {\n            text += spaces + '</' + node.name + '>\\n';\n        }\n    }\n    return text;\n}\n\n\n\nexport default function angularEnforcer (fileData, options) {\n    return new Promise((resolve, reject) => {\n        let data = fileData.replace(/\\>[\\s]+\\</gi, '><')\n            .replace(/\\n\\s+/gi, ' ');\n\n        let handler = new DefaultHandler((err, dom) => {\n            if (err) {\n                reject(err);\n            } else {\n                //console.log(JSON.stringify(dom, null, 4));\n                let final_text = '';\n                dom.forEach((node) => {\n                    final_text += parseNode(node);\n                });\n                //console.log(final_text);\n                resolve(final_text);\n            }\n\n        }, {ignoreWhitespace: true});\n        let parser = new Parser(handler);\n        parser.parseComplete(data);\n    });\n}\n"]}